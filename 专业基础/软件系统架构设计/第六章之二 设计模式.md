---
title: 第六章之二 设计模式
date: 2021-12-07 20:00:19
tags: [软件工程, 软件系统架构设计, 设计模式]
categories: 专业基础
---

# 设计模式概述

* 设计模式( Design pattern)是一套被反复使用的、经过分类编目的*面向对象程序设计经验*总结。
  * 设计模式代表了*最佳的面向对象程序设计实践*，通常被有经验的面向对象软件开发人员所采用。
  * 设计模式是面向对象设计中*典型问题的解决方案*。
* 设计模式作用：
  * 实现代码编写的*规范化*，像生产制造计算机硬件设备一样，标准化开发软件构件。
  * 支持编写*可扩展、易维护、好管理*的程序代码。
  * 让代码更容易被他人*理解*，确保代码可靠性、重用性。
* 设计模式类型：
  1. 创建模式：提供一种*创建对象而隐藏创建逻辑*的方法，给出灵活创建对象的解决方案。
  2. 结构模式：给出*利用继承、接口组合对象以获得新功能*的解决方案。
  3. 行为模式：用于描述*对象之间协作完成特定功能及其职责分配*，给出*对象之间通信*的解决方案。

# 创建型模式

* 创建型模式的关注点是“怎样创建对象?”，它的主要特点是*将对象，的创建与使用分离*，从而降低对象之间的耦合度。
* 使用者*不需要关注对象的创建细节*，对象的创建由相关工厂来完成。
* 创建型模式类型：
  * 单例模式(Singleton Pattern)
  * 工厂模式(Factory Pattern)
  * 抽象工厂模式(Abstract Factory Pattern)
  * 建造者模式(Builder Pattern)
  * 原型模式(Prototype Pattern)

## 单例模式

* 单例模式是指*一个类只有一个实例，且该类能自行创建这个实例*的一种程序设计模式。

* 模式创造动机：一些应用程序虽然*可以创建多个进程任务并发运行，但同一时段只允许一-个进程任务在处理*。如打印程序可以运行多个进程任务，但同一时段只执行一个打印任务。此外，计算机系统中还有不少程序需要采用单一进程处理，如下：

  * Windows的回收站
  * 操作系统中的文件系统.
  * 多线程中的线程池、数据库的连接池
  * 应用程序的对话框
  * Web应用的配置对象

* 模式作用：该模式通过唯一的实例进行服务资源访问可以解决多实例模式带来的*系统开销问题*。

* 模式特点：

  * 单例模式类*只能创建一个实例对象*
  * 该实例对象必须*由单例模式类自行创建*
  * 单例模式类对外*仅提供一个访问该单例的全局访问点*。

* 模式设计方案：

  * 只涉及一个类，它负责创建一个对象，同时确保只创建一个对象Singleton。

  * 这个类*提供了一种方法`get Instance ()`来访问它的唯一对象*。

    ![](https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20211207211858.png)

* 模式实现方案：

  * **饿汉式单例类**:在单例*类被加载时候，就实例化一个对象*交给自己的引用。构造对象时，该对象就已经实际被创建了，在调用`getInstance()`方法时，只不过是返回创建好的对象。

    ```java
    public class Singleton{
    	private static Singleton singleton = new Singleton() ;//指向自己实例的私有静态引用
    	private Singleton() {} //私有的构造方法
    	public static Singleton getInstance() { //以自己实例为返回值的静态公有方法
    		return singleton; 
        }
    }
    ```

  * **懒汉式单例类**：在*访问实例对象时才实例化对象*。构造对象时，并没有实际创建对象，而是直到调用`getInstance`的时候才创建对象返回。

    ```java
    public class Singleton{
    	private static Singleton singleton; //私有的静态对象变量定义
    	private Singleton() {} //私有的构造方法
         //访问实例对象时创建单例类实例
        //设置同步锁，是防止多个线程同时调用该方法，导致创建多个实例对象
    	public static synchronized Singleton getInstance() {
            //
    		if (singleton==null){ 
                singleton = new Singleton(); 
            }
    		return singleton; 
        }
    ```

* 适用场景：

  * 需要*频繁实例化对象，然后销毁对象*。
  * *创建对象时开销较大*，但又需经常使用该对象。
  * 有*状态*的工具类对象。
  * *频繁访问数据库或文件*的对象（防止数据修改冲突）。

* 应用示例：用懒汉式单例模式模拟产生美国当今总统对象。

  ![](https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20211207214147.png)

  * 创建一个`President`类。该类提供了一个静态方法，供外界获取它的静态实例。

  * `SingletonLazy`类使用`President`单例类来获取`President`对象。

  * 代码：

    ```java
    class President{
        private static volatile Pres ident instance = null;
        private President(){ //private避免类在外部被实例化
        	System. out. printIn("产生一个总统! ");
        }
        public static synchronized President getInstance (){
            //在getInstance方法上加同步，以确保并发线程同步
            if (instance == null) {
            	instance = new President() ;
            } else {
            	System.out.println("已经有一个总统，不能产生新总统!");
            	return instance;
            }
        }	
        public void getName () {
       	 System.out.println("我是美国总统:拜登");
        }
    }
    
    public class SingletonLazy{
        public static void main(String] args){
            President zt1 = President.getInstance();
            zt1.getName(); //输 出总统的名字
            President zt2 = President.getInstance();
            zt2.getName(); //输出 总统的名字
            if (zt1 == zt2) {
            System.out.println("他们是同一人! ") ;
            } eIse {
            System.out.println("他们不是同一人! ") ;
        	}
        }
    }
    ```

* 模式优点：
  * 在内存中一个类只有一个实例，减少了*程序占用内存的开销*。
  * *避免频繁的创建和销毁实例*，可以提高软件程序运行性能。
  * 避免对资源的*多重占用*。
  * 单例模式设置为全局访问点，可以*共享资源访问*。
* 模式缺点：
  * 单例模式一般没有接口，*扩展困难*。如果要扩展，需修改原来的代码，这违背开闭原则。
  * 在*并发编程中，单例模式不利于代码调试*。在调试过程中，如果单例中的代码没有执行完，不能模拟生成一个新的对象。
  * 单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很*容易违背单一职责原则*。

## 工厂模式

* 工厂模式是指定义一个创建产品对象的工厂接口，将产品对象的实际*创建工作推迟到具体子工厂类当中*。
* 工厂模式作用：
  * 给代码结构提供*扩展性*，屏蔽每个功能类中的具体实现逻辑。
  * 提供一种通过统一接口创建所需对象的模式。从而满足创建型模式中所要求的“*创建与使用相分离*”的特点。
  * 在创建对象时，*对客户端不暴露创建的代码逻辑*，仅通过使用一个通用的接口来引用新创建的对象。
  * 解决接口选择的问题。

* 工厂模式设计方案：

  ![image-20211214105400669](/Users/zhangjie/Library/Application Support/typora-user-images/image-20211214105400669.png)

  * **工厂接口(IFactory)** :通过接口为访问者*提供产品服务*。
  * **工厂实现(Factory) **:实现工厂接口，并调用产品实现*创建产品*。如果有多种产品，就需要有多种工厂实现。
  * **产品接口(IProduct)** :定义产品的接口，它*描述了产品的主要特性和功能*。
  * **产品实现(Product)**:实现产品接口所定义的操作方法，它*由工厂实现来创建，并与工厂实现，之间一一对应*。

* 工厂模式实现方案：

```java
//产品接口
interface IProduct {
  public void productMethod();
}
//产品实现
class Product implements IProduct{
  public void productMethod (){
    	System.out.println("产品");
  }
}
//工厂接口
interface IFactory {
  public IProduct createProduct();
}
//工厂实现类
class Factory implements IFactory {
  public IProduct createProduct(){
    return new Product();
	}
}
//客户端
public class Client {
  public static void main(String[] args) {
    IFactory factory  = new Factory();
    IProduct product = factory.createProduct();
    product.productMethod();
  }
}
```

