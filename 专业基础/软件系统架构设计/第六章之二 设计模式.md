---
title: 第六章之二 设计模式
date: 2021-12-07 20:00:19
tags: [软件工程, 软件系统架构设计, 设计模式]
categories: 专业基础
---

# 设计模式概述

* 设计模式( Design pattern)是一套被反复使用的、经过分类编目的*面向对象程序设计经验*总结。
  * 设计模式代表了*最佳的面向对象程序设计实践*，通常被有经验的面向对象软件开发人员所采用。
  * 设计模式是面向对象设计中*典型问题的解决方案*。
* 设计模式作用：
  * 实现代码编写的*规范化*，像生产制造计算机硬件设备一样，标准化开发软件构件。
  * 支持编写*可扩展、易维护、好管理*的程序代码。
  * 让代码更容易被他人*理解*，确保代码可靠性、重用性。
* 设计模式类型：
  1. 创建模式：提供一种*创建对象而隐藏创建逻辑*的方法，给出灵活创建对象的解决方案。
  2. 结构模式：给出*利用继承、接口组合对象以获得新功能*的解决方案。
  3. 行为模式：用于描述*对象之间协作完成特定功能及其职责分配*，给出*对象之间通信*的解决方案。

# 创建型模式

* 创建型模式的关注点是“怎样创建对象?”，它的主要特点是*将对象，的创建与使用分离*，从而降低对象之间的耦合度。
* 使用者*不需要关注对象的创建细节*，对象的创建由相关工厂来完成。
* 创建型模式类型：
  * 单例模式(Singleton Pattern)
  * 工厂模式(Factory Pattern)
  * 抽象工厂模式(Abstract Factory Pattern)
  * 建造者模式(Builder Pattern)
  * 原型模式(Prototype Pattern)

## 单例模式

* 单例模式是指*一个类只有一个实例，且该类能自行创建这个实例*的一种程序设计模式。

* 模式创造动机：一些应用程序虽然*可以创建多个进程任务并发运行，但同一时段只允许一-个进程任务在处理*。如打印程序可以运行多个进程任务，但同一时段只执行一个打印任务。此外，计算机系统中还有不少程序需要采用单一进程处理，如下：

  * Windows的回收站
  * 操作系统中的文件系统.
  * 多线程中的线程池、数据库的连接池
  * 应用程序的对话框
  * Web应用的配置对象

* 模式作用：该模式通过唯一的实例进行服务资源访问可以解决多实例模式带来的*系统开销问题*。

* 模式特点：

  * 单例模式类*只能创建一个实例对象*
  * 该实例对象必须*由单例模式类自行创建*
  * 单例模式类对外*仅提供一个访问该单例的全局访问点*。

* 模式设计方案：

  * 只涉及一个类，它负责创建一个对象，同时确保只创建一个对象Singleton。

  * 这个类*提供了一种方法`get Instance ()`来访问它的唯一对象*。

    ![](https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20211207211858.png)

* 模式实现方案：

  * **饿汉式单例类**:在单例*类被加载时候，就实例化一个对象*交给自己的引用。构造对象时，该对象就已经实际被创建了，在调用`getInstance()`方法时，只不过是返回创建好的对象。

    ```java
    public class Singleton{
    	private static Singleton singleton = new Singleton() ;//指向自己实例的私有静态引用
    	private Singleton() {} //私有的构造方法
    	public static Singleton getInstance() { //以自己实例为返回值的静态公有方法
    		return singleton; 
        }
    }
    ```

  * **懒汉式单例类**：在*访问实例对象时才实例化对象*。构造对象时，并没有实际创建对象，而是直到调用`getInstance`的时候才创建对象返回。

    ```java
    public class Singleton{
    	private static Singleton singleton; //私有的静态对象变量定义
    	private Singleton() {} //私有的构造方法
         //访问实例对象时创建单例类实例
        //设置同步锁，是防止多个线程同时调用该方法，导致创建多个实例对象
    	public static synchronized Singleton getInstance() {
            //
    		if (singleton==null){ 
                singleton = new Singleton(); 
            }
    		return singleton; 
        }
    ```

* 适用场景：

  * 需要*频繁实例化对象，然后销毁对象*。
  * *创建对象时开销较大*，但又需经常使用该对象。
  * 有*状态*的工具类对象。
  * *频繁访问数据库或文件*的对象（防止数据修改冲突）。

* 应用示例：用懒汉式单例模式模拟产生美国当今总统对象。

  ![](https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20211207214147.png)

  * 创建一个`President`类。该类提供了一个静态方法，供外界获取它的静态实例。

  * `SingletonLazy`类使用`President`单例类来获取`President`对象。

  * 代码：

    ```java
    class President{
        private static volatile Pres ident instance = null;
        private President(){ //private避免类在外部被实例化
        	System. out. printIn("产生一个总统! ");
        }
        public static synchronized President getInstance (){
            //在getInstance方法上加同步，以确保并发线程同步
            if (instance == null) {
            	instance = new President() ;
            } else {
            	System.out.println("已经有一个总统，不能产生新总统!");
            	return instance;
            }
        }	
        public void getName () {
       	 System.out.println("我是美国总统:拜登");
        }
    }
    
    public class SingletonLazy{
        public static void main(String] args){
            President zt1 = President.getInstance();
            zt1.getName(); //输 出总统的名字
            President zt2 = President.getInstance();
            zt2.getName(); //输出 总统的名字
            if (zt1 == zt2) {
            System.out.println("他们是同一人! ") ;
            } eIse {
            System.out.println("他们不是同一人! ") ;
        	}
        }
    }
    ```

* 模式优点：
  * 在内存中一个类只有一个实例，减少了*程序占用内存的开销*。
  * *避免频繁的创建和销毁实例*，可以提高软件程序运行性能。
  * 避免对资源的*多重占用*。
  * 单例模式设置为全局访问点，可以*共享资源访问*。
* 模式缺点：
  * 单例模式一般没有接口，*扩展困难*。如果要扩展，需修改原来的代码，这违背开闭原则。
  * 在*并发编程中，单例模式不利于代码调试*。在调试过程中，如果单例中的代码没有执行完，不能模拟生成一个新的对象。
  * 单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很*容易违背单一职责原则*。

## 工厂模式

* 工厂模式是指定义一个创建产品对象的工厂接口，将产品对象的实际*创建工作推迟到具体子工厂类当中*。
* 工厂模式作用：
  * 给代码结构提供*扩展性*，屏蔽每个功能类中的具体实现逻辑。
  * 提供一种通过统一接口创建所需对象的模式。从而满足创建型模式中所要求的“*创建与使用相分离*”的特点。
  * 在创建对象时，*对客户端不暴露创建的代码逻辑*，仅通过使用一个通用的接口来引用新创建的对象。
  * 解决接口选择的问题。

* 工厂模式设计方案：

  ![](https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20211216102631.png)

  * **工厂接口(IFactory)** :通过接口为访问者*提供产品服务*。
  * **工厂实现(Factory) **:实现工厂接口，并调用产品实现*创建产品*。如果有多种产品，就需要有多种工厂实现。
  * **产品接口(IProduct)** :定义产品的接口，它*描述了产品的主要特性和功能*。
  * **产品实现(Product)**:实现产品接口所定义的操作方法，它*由工厂实现来创建，并与工厂实现，之间一一对应*。

* 工厂模式实现方案：

```java
//产品接口
interface IProduct {
  public void productMethod();
}
//产品实现
class Product implements IProduct{
  public void productMethod (){
    	System.out.println("产品");
  }
}
//工厂接口
interface IFactory {
  public IProduct createProduct();
}
//工厂实现类
class Factory implements IFactory {
  public IProduct createProduct(){
    return new Product();
	}
}
//客户端
public class Client {
  public static void main(String[] args) {
    IFactory factory  = new Factory();
    IProduct product = factory.createProduct();
    product.productMethod();
  }
}
```

* 适用场景：
  * 当一个类希望由子类来指定所创建对象的时候，如*日志记录器*，可以将数据记录到本地硬盘，也可以记录到远程服务器。
  * 当*数据库连接访问*，可以动态选择连接哪一个数据库。
  * 连接一个服务器，可能需要三个协议(“POP3” 、“IMAP” 、“HTTP”)之一，可以把这三个作为功能类，*共同提供一个接口对外访问*。
* 示例：
  * 创建一个*Shape接口*和*实现Shape接口*的Circle实体类、Square实体类、Rectangle实体类。
  * 定义工厂类`ShapeFactory`。
  * FactoryPatternDemo类使*用ShapeFactory来获取Shape对象*。它将向ShapeFactory 传递信息( Circle\Square\Rectangle )，以便获取它所需对象的类型。

![](https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20211215223937.png)

```java
public interface Shape {
	void draw();
}

public class Circle implements Shape {
	@Override
	public void draw() {
		System.out.println("Inside Circle::draw() method.");
	}
}

public class Square implements Shape {
    @Override
    public void draw() {
        System.out.println("Inside Square::draw() method.")
    }
}

public class Rectangle implements Shape {
    @Override
    public void draw() {
        System.out.println("Inside Rectangle::draw() method.")
    }
}

public class ShapeFactory {
    //使用getShape方法获取形状类型的对象
    public Shape getShape(String shapeType){
    	if( shapeType == nu11){
    		return nu11;
        }
    	if( shapeType.equalsIgnoreCase("CIRCLE")) {
    		return new Circle();
        } else if( shapeType.equalsIgnoreCase ("RECTANGLE")){
    		return new Rectangle();
    	} else if( shapeType.equalsIgnoreCase("SQUARE")){
    		return new Square();
    	}
    	return nu11;
    }
}
```

* 模式优点：
  * 一个调用者想创建一个对象，只要知道其名称就可以了。
  * 若想增加一个功能，只需扩展一个工厂类就可以。
  * 屏蔽产品的具体实现，调用者只关心产品的接口。
* 模式缺点：
  * 每次*增加一个产品时，都需要增加一个具体类实现工厂*，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度。
  * 同时也增加了系统*具体类的依赖*。

# 结构型模式

* 结构型模式描述如何*将类或对象按某种布局组成更大的结构*。
* 它分为*类结构型模式*和*对象结构型模式*，前者采用*继承*机制来组织接口和类，后者采用*组合或聚合*来组织对象。
* 结构型模式类型：
  * 适配器模式(Adapter Pattern)
  * 桥接模式(Bridge Pattern) 
  * 装饰器模式(Decorator Pattern)
  * 外观模式(Facade Pattern)
  * 过滤器模式(Filter Pattern)
  * 组合模式(Composite Pattern)
  * 享元模式(Flyweight Pattern)
  * 代理模式(Proxy Pattern)

## 适配器模式

* 适配器模式将一个类的*接口转换*成客户希望的另外一个接口，使得原本由于*接口不兼容*而不能一-起工作的那些类能一起工作。

* 模式作用：

  * 需要开发的功能类在现有的类库中已经存在，但它们与当前系统的*接口规范不兼容*。如果重新开发这些类成本又很高，这时可以使用适配器模式来解决*现有类的复用问题*。
  * 系统需要使用现有的类，而此类的*接口*不符合系统的需要。
  * 通过*接口转换*，使一个类可以访问另一个类。

* 模式设计方案：

  * **目标接口(Target)** :当前系统业务所*期待的接口*，它也可以是抽象类。
  * **适配者类(Adaptee)** : 它是被访问和适配的*现存组件库中的接口类*。
  * **适配器类(ClassAdapter )** :它是一个*转换器*，通过*继承或引用*适配者的对象，把适配者接口转换成目标接口，让客户端类按目标接口的格式访问适配者。

  ![](https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20211216103156.png)

* 模式实现方案：

  ```java
  //目标接口.
  interface Target {
      public void request() ;
  }
  //适配者接口类
  class Adaptee {
  	public void specificRequest();
      System.out.println("适配者中的业务代码");
  }
  //适配器类
  class ClassAdapter extends Adaptee implements Target {
      //将适配者的方法包装在目标接口的方法中，实现调用目标接口的方法却能实现适配者功能的效果
      public void request() {
         specificRequest();
      }
  }
  //客户端类代码
  public class ClassAdapterTest {
      public static void main(String[] args) {
          System.out.println("类适配器模式测试：");
          Target target = new ClassAdapter();
          target.request();
      }
  }
  ```

* 适用场景：

  * *不想修改原有代码而重用现有的适配者类*。将一个类的接口转换成客户希望的另外一个接口，使得原本由于*接口不兼容*而不能一起工作的那些类能一起工作。
  * 以前开发的系统存在*满足新系统功能需求的类*，但其接口同新系统的接口不一致。
  * 使用*第三方提供的类*，但类接口定义和自己要求的接口定义不同。

* 应用示例：

  ​	![](https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20211216104525.png)

  * 为了实现AudioPlayer播放其他格式的音频文件。需要创建一个实现MediaPlayer接口的适配器类MediaAdapter,并使用AdvancedMediaPlayer对象来播放所需的格式。

  * AudioPlayer使用适配器类MediaAdapter传递所需的*音频类型*，不需要知道能播放所需格式音频的实际类。

  * AdapterPatternDemo类使用AudioPlayer类和适配器类MediaAdapter来*播放各种格式文件*。

  * 代码：

    ```java
    //为媒体播放器创建接口
    public interface MediaPlayer {
    	public void play(String audioType, String fileName);
    }
    //为高级媒体播放器创建接口
    public interface AdvancedMediaPlayer {
    	public void playVlc(String fileName);
    	public void playMp4(String fileName);
    }
    //创建实现了AdvancedMediaPlayer 接口播放vlc的实体类
    public class VlcPlayer implements AdvancedMediaPlayer{
    	@Override
    	public void playVlc(String fileName) {
    		System.out.println( "播放vlc file.Name: "+ fileName) ;
    	}
    	@override 
    	public void playMp4(String fileName ) {
    		//什么也不做
        }
    }
    
    //创建实现了AdvancedMediaPlayer 接口播放MP4的实体类
    public class Mp4Player implements AdvancedMediaPlayer{
    	@Override
    	public void playVlc(String fileName) {
            //什么也不做
    	}
    	@override 
    	public void playMp4(String fileName ) {
    		System.out.println( "播放Mp4 file.Name: "+ fileName) ;
        }
    }
    
    //创建实现了MediaPlayer接口的适配器类
    public class MediaAdapter implements MediaPlayer {
    	AdvancedMediaPlayer advancedMusicPlayer; 
        //构造器，根据音乐类型来初始化不同类型的高级音乐播放器
    	public MediaAdapter(String audioType){
    		if( audioType.equalsIgnoreCase("vlc") ){
    			advancedMusicPlayer = new VlcPlayer();
    		} else if (audioType.equalsIgnoreCase( "mp4")){
    			advancedMusicPlayer = new Mp4Player( );
            }
        }
    	@Override
    	public void play(String audioType, String fileName) {
            //使用高级音乐播放器来播放不同的类型的音乐
    		if( audioType.equalsIgnoreCase("vlc")){
    			advancedMusicPlayer.playVlc(fileName);，
    		}else if(audioType. equalsIgnoreCase( " mp4" ) ){
    			advancedMusicPlayer.playMp4(fileName) ; 
            }
        }
    }
    
    //创建实现了MediaPlayer接口的实体类
    public class AudioPlayer implements MediaPlayer {
    	MediaAdapter mediaAdapter ;
    	@Override
    	public void play(String audioType, String fileName) {
    		//播放mp3音乐文件的内置支持
    		if(audioType.equalsIgnoreCase( "mp3")){
    			System.out.println("Playing mp3 file. Name: "+ fileName); 
            }//mediaAdapter提供了播放其他文件格式的支持
    		else if( audioType.equalsIgnoreCase("vlc"))  || audioType.equalsIgnoreCase ( "mp4")){
                //先根据音乐类型构造适配器，再使用适配器播放
    			mediaAdapter = new MediaAdapter( audioType) ; 
    			mediaAdapter.play(audioType, fileName); 
            } else {
    			System.out.println("Invalid media. "+ audioType +”format not 					supported") ;
            }
    }
    //使用AudioPlayer 来播放不同类型的音频格式
    public class AdapterPatternDemo {
    	public static void main(String[] args) {
            //最后使用实现了适配器的AudioPlayer类，无缝播放各种类型
            AudioPlayer audioPlayer = new AudioPlayer() ;
            audioPlayer.play( "mp3"，" beyond the horizon. mp3" ) ;
            audioPlayer.play( "mp4"，"alone . mp4") ;
            audioPlayer.play("v1c"，"far far away. vlc");
            audioPlayer.play("avi"，" mind me. avi" ) ;
    	}
    }
    ```

* 模式优点：
  * 客户端通过适配器可以透明地调用目标接口。
  * *复用*了现存的类，程序员不需要修改原有代码而重用现有的适配者类。
  * 将目标类和适配者类*解耦*，解决了目标类和适配者类接口不一致的问题。
  * 在很多业务场景中符合*开闭原则*。
* 模式缺点：
  * 适配器编写过程需要结合业务场景全面考虑，可能会增加系统的*复杂性*。
  * 增加代码阅读难度，降低代码可读性，过多使用适配器会使系统*代码变得凌乱*。

## 桥接模式

* 桥接模式是一种用于把*抽象化与实现化解耦*，使得二者可以独立变化的设计模式。它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。

* 模式作用：

  * 在一些应用中，某类*具有两个或多个维度的变化*，如既可按形状分，又可按颜色分。如在设计类实现不同形状和不同颜色的图形绘制中，如果用继承方式，m种形状和n种颜色的图形就有mXn种，其对应的子类很多，而且扩展困难。当采用桥接模式可以将抽象化与实现化解耦，使得*二者可以独立变化*，从而降低抽象和实现这两个可变维度的耦合度。
  * 将抽象部分与实现部分分离，使它们都可以*独立地进行变化*。
  * 在*有多种可能会变化*的情况下，用*继承会造成类爆炸问题，扩展起来不灵活*。

* 模式设计方案：通过接口实现的不同与抽象类实现的不同来组合出多种不同的实现方案。在抽象类中使用接口的功能来将两种不同的实现连接起来。

  * **抽象类( Abstraction)**: 维护一个指向`Implementor`类型的指针。

  * **扩展抽象类(RefineedAbstraction)**: 扩充抽象类`Abstraction`功能。

  * **实现接口类(Implementor)**:定义实现类的接口。

  * **具体实现类(ConcreteImplementor )**: 具体定义实现类。

    ![](https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20211217101532.png)

* 模式实现方案：

  ```java
  public class BridgeTest {
  	public static void main(String[] args) {
          Implementor imple = new ConcreteImplementorA();
          Abstraction abs = new RefinedAbstraction(imple);
          abs.Operation();
      }
  }
  //实现化接口
  interface Implementor {
  	public void OperationImpl();
  }
  //具体实现化角色
  class ConcreteImplementorA implements Implementor {
      @Override
      public void OpreationImpl() {
          Systemt.out.println("具体实现化(Concrete ImplementorA)角色被访问");
      }
  }
  //抽象化角色
  abstract class Abstraction {
      protected Implementor imple;
      protected Abstraction(Implementor imple) {
          this.imple = imple;
      }
      public abstract void Operation();
  }
  //扩展抽象化角色
  class RefinedAbstraction extends Abstraction {
      protected RefinedAbstraction(Implementor imple) {
          super(imple);
      }
      public void Operation() {
          System.out.println("扩展抽象化(Refined Abstraction)角色被访问");
          imple.OpreationImpl();
  	}
  }
  ```

* 适用场景：

  * 当一个类存在*两个独立变化的维度*，且这两个维度都需要进行扩展。
  * 当一个系统*不希望使用继承或因为多层次继承导致系统类的个数急剧增加*。
  * 当一个系统需要*在构件的抽象化角色和具体化角色之间增加更多的灵活性*。

* 示例：

  * 作为桥接实现的`DrawAPI`接口和实现`DrawAPI`接口的实体类`RedCircle `、`GreenCircle`。
  * `Shape`是一个抽象类，将使用`DrawAPI `的对象。
  * `BridgePatternDemo`类使用`Shape`类来画出*不同颜色的圆*。
  * 有两个变化维度：`DrawAPI`接口对应的不用颜色，和`Shape`抽象类对应的不用形状（本例中只实现了圆形）

  ![](https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20211217103357.png)

```java
//创建桥接实现接口
public interface DrawAPI {
	public void drawCircle(int radius, int x, int y);
}
//创建实现了DrawAPI 接口的实体桥接实现类
public class RedCircle implements DrawAPI {
	@Override
	public void drawCircle(int radius, int x, int y) {
		System.out.println( "画圆[ color: red, radius :
							+radius+”，x:
                           +X+","+ y +"]");
    }
}
//创建实现 了DrawAPI 接口的实体桥接实现类
public class GreenCircle implements DrawAPI {
	@Override
	public void drawCircle(int radius, int x，int y) {
		System. out. println("画圆[ color: green, radius:
                             + radius + "，x:
                             +X+"，
                             + y +"]");
        }
}
//使用DrawAPI 接口创建抽象类Shape
public abstract class Shape {
    //抽象类中使用接口来连接两种变化
    protected DrawAPI drawAPI ;
	protected Shape (DrawAPI drawAPI){
		this. drawAPI = drawAPI ;
	}
    
	public abstract void draw( ) ;
}

//创建实现了 Shape接口的实体类
public class Circle extends Shape {
	private int x， y, radius ;
	public Circle(int x，int y, int radius, DrawAPI drawAPI) {
		super( drawAPI) ;
		this.x = x;
        this.y = y;
		this.radius = radius;
	public void draw( ) {
		drawAPI.drawCircle(radius,x,y);
	}
}
//使用Shape和DrawAPI类画出不同颜色的圆
public class BridgePatternDemo {
	public static void main(String[ ] args) {
		Shape redCircle = new Circle(100,100, 10，new RedCircle());
		Shape greenCircle = new Circle(100,100, 10，new GreenCircle());
		redCircle.draw() ;
		greenCircle.draw();
    }
```

* 模式优点：
  * *抽象和实现的分离*有助于降低对实现部分*编译时的依赖*
  * 提高*可扩展能力*，可独立地对抽象和实现的层次结构进行扩充
  * 实现细节对客户透明
  * 符合*开闭原则*
* 模式缺点：
  * 桥接模式会增加系统的*理解与设计难度*
  * 由于聚合关联关系建立在抽象层，要求开发者*针对抽象进行设计与编程*。

# 行为型模式

* 行为型模式用于描述程序在运行时存在的*复杂流程控制*，即描述多个类或对象之间*相互协作*完成单个对象都无法单独完成的任务，以及如何分配职责。
* 行为型模式类型：
  * 责任链模式(Chain of Responsibility Pattern)
  * 命令模式(Command Pattern)
  * 解释器模式( Interpreter Pattern)
  * 迭代器模式( Iterator Pattern)
  * 中介者模式(Mediator Pattern)
  * 观察者模式(Observer Pattern)
  * 备忘录模式(Memento Pattern)

## 责任链模式

* 责任链模式是一种将*请求发送到处理对象链*的设计模式。
* 模式作用：
  * 为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链;当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。
  * *职责链上的处理者负责处理请求*，客户*只需要将请求发送到职责链上即可*，无须关心请求的处理细节和请求的传递。
  * 职责链*将请求的发送者与处理者进行解耦*。
* 模式设计方案：

