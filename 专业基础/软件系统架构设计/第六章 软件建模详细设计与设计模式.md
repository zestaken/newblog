---
title: 第六章 软件建模详细设计与设计模式
date: 2021-11-29 11:29:19
tags: [软件工程, 软件系统架构设计]
categories: 专业基础
---

# 软件建模详细设计概述

## 软件详细建模设计目标

* 软件详细建模设计是在软件架构模型设计基础上，对系统中各模型进一步细
  化设计，给出软件程序*实现的设计方案*。

## 软件建模详细设计原则

### 1. 开闭原则

* 软件实体(对象、类、模块等)应该*对扩展开放性，对修改具有封闭性*。
* 当应用的需求改变时，在*不修改软件实体源代码的前提*下，就可以扩展模块的功能，使其满足新的需求。
* 示例：环境监测器设计![wPgX4w](https://gitee.com/zhangjie0524/picgo/raw/master/uPic/wPgX4w.png)

### 2. 里氏(Liskov)替换原则

* 子类可以*扩展基类的功能，但不能改变基类原有的功能*。
* 子类在继承基类时，*除了添加新的方法且完成新增功能外，不要重写基类的
  方法*。
* 子类必须遵守基类与使用该基类的构件之间的隐含约定。

* 示例：鸟类飞行速度测试程序设计

  * 初始设计：

    <img src="https://gitee.com/zhangjie0524/picgo/raw/master/uPic/KwT7Rl.png" alt="KwT7Rl"  />

    * 几维鸟没有飞行速度（飞行速度为0），计算几维鸟的飞行时间就会变成无限；

  * 按照里氏替换原则设计：

    ![m8X9ps](https://gitee.com/zhangjie0524/picgo/raw/master/uPic/m8X9ps.png)

    * 先设计一个动物类，然后鸟类继承这个动物类，只需增加设置飞行速度和获取飞行时间的方法，不用重写原来的方法。而几维鸟没有飞行速度，直接继承动物类就可以实现功能。

### 3. 依赖倒置原则

* *抽象不应该依赖细节，细节应该依赖抽象*；

* *面向接口编程*，不要面向实现编程。

* 基于*抽象(抽象类、接口)编程访问可以容易实现扩展*。

* 示例：顾客购物程序设计

  * 一般设计：

    ![XPxjzA](https://gitee.com/zhangjie0524/picgo/raw/master/uPic/XPxjzA.png)

  * 面向接口编程：不用直接修改源代码即可增加功能

    ![6pzJGO](https://gitee.com/zhangjie0524/picgo/raw/master/uPic/6pzJGO.png)

### 4.接口分离原则

* 为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。

* 提供者构件应该为每个主要的客户构件类型提供一个特定的接口。

* 示例：学生成绩管理系统

  ![oLAOlV](https://gitee.com/zhangjie0524/picgo/raw/master/uPic/oLAOlV.png)

### 5. 单一职责原则

* 一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分。

* 单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性。

* 作用：

  * 降低类的*复杂度*。一个类只负责一项职责，其逻辑肯定要比负责多项职责
    简单得多。
  * 提高类的*可读性*。复杂性降低，自然其可读性会提高。.
  * 提高系统的*可维护性*。可读性提高，那自然更容易维护了。

* 示例：学生工作管理

  ![djPc0j](https://gitee.com/zhangjie0524/picgo/raw/master/uPic/djPc0j.png)

### 6. 最少知识原则（迪米特法则）

* 迪米特法则的定义是:只与你的朋友交谈，不跟“陌生人”说话。在程序设计中，如果*两个软件实体无须直接关系，那么就不应当直接的相互调用，可以通过第三方转发该调用*。
* 作用：
  * 降低了类之间的*耦合度*，提高了模块的相对独立性。
  * 由于耦合度降低，从而提高了*类的可复用性和系统的扩展性*。
* 示例：明星与经纪人

​		![rBiKnV](https://gitee.com/zhangjie0524/picgo/raw/master/uPic/rBiKnV.png)

### 7. 高内聚原则

* 内聚性意味着构件或者类*只封装那些密切关联的属性和操作*。
* 内聚性级别，由强到弱分为：
  * 功能内聚:模块内的所有元素紧密配合完成同一个*功能*，即满足单一职责原则。
  * 分层内聚:系统采用*分层*结构，高层能够访问低层服务，但低层不能访问高层服务。
  * 通信内聚:模块内的所有元素都访问相同的*数据*。通信内聚通常用于数据的查询、访问和存储。
* 一般来说，内聚性越高，构件越易于实现、测试和维护。

### 8. 低耦合原则

* 耦合性指不同对象之间*相互关联的程度*。如果一个对象过多地依赖于其它对象来完成自己的工作，这会增加测试、修改的难度，同时降低了类的可重用性和可移植性。
* 在详细设计中要尽可能保持低耦合。但是软件必须进行内部和外部的通信因此*耦合是必然存在的*。当两个对象必须相互联系时，应该*通过类的公共接口实现耦合，不应该依赖于类的具体实现细节*。

### 9. 可重用原则

* 为了提高工作效率、减少错误、降低成本，要充分考虑软件元素的重用性。
* 重用性有两个方面的含义:
  * 尽量使用已有的类， 如开发环境提供的类库;
  * 在设计新类时考虑将来的可重用性。
* 作用：设计一个可重用的软件比设计一个普通软件的代价要高，但是随着这些软件被重用次数的增加，分摊到它的设计和实现成本就会降低。

## 软件建模详细设计内容

* 类图：定义和细化类，对软件静态结构模型的类图进行详细设计
* 动态交互图：分析对象之间的交互关系，对软件动态行为模型的交互图进行详细设计
* 状态机图：分析对象生命周期的状态变化，对反映对象状态变迁的状态机图进行详细设计
* 构件图、部署图：对反映软件物理实现模型的构件图和部署图进行详细设计

# UML软件静态结构视图建模

